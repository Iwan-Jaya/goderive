The deriveUnion function returns the union of two lists or maps.

Given the following input:

```go
package union

type Person struct {
	Name string
	Vote *string
}

func ratio(survey, database []*Person) float64 {
	union := deriveUnion(deriveUnique(database), survey)
	if len(union) == 0 {
		return 0
	}
	voted := deriveFilter(func(p *Person) bool {
		return p.Vote != nil
	}, union)
	return float64(len(voted)) / float64(len(union))
}
```

goderive will generate the following code:

```go
// Code generated by goderive DO NOT EDIT.

package union

func deriveUnique(list []*Person) []*Person {
	if len(list) == 0 {
		return nil
	}
	u := 1
	for i := 1; i < len(list); i++ {
		if !deriveContains(list[:u], list[i]) {
			if i != u {
				list[u] = list[i]
			}
			u++
		}
	}
	return list[:u]
}

// deriveFilter returns a list of all items in the list that matches the predicate.
func deriveFilter(predicate func(*Person) bool, list []*Person) []*Person {
	out := make([]*Person, 0, len(list))
	for i, elem := range list {
		if predicate(elem) {
			out = append(out, list[i])
		}
	}
	return out
}

func deriveUnion(union, that []*Person) []*Person {
	for i, v := range that {
		if !deriveContains(union, v) {
			union = append(union, that[i])
		}
	}
	return union
}

// deriveContains returns whether the item is contained in the list.
func deriveContains(list []*Person, item *Person) bool {
	for _, v := range list {
		if deriveEqual(v, item) {
			return true
		}
	}
	return false
}

// deriveEqual returns whether this and that are equal.
func deriveEqual(this, that *Person) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Name == that.Name &&
			((this.Vote == nil && that.Vote == nil) || (this.Vote != nil && that.Vote != nil && *(this.Vote) == *(that.Vote)))
}
```