The deriveMem function returns the a memoized version of the input function.

Given the following input:

```go
package mem

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type User struct {
	Name string
}

func getUser(version int, id int) (User, error) {
	resp, err := http.Get(fmt.Sprintf("localhost:8080/user/%d/%d", version, id))
	if err != nil {
		return User{}, nil
	}
	u := &User{}
	if err := json.NewDecoder(resp.Body).Decode(u); err != nil {
		return User{}, nil
	}
	return *u, nil
}

var mgetUser = deriveMem(getUser)

func GetUser(version int, id int) (User, error) {
	return mgetUser(version, id)
}
```

goderive will generate the following code:

```go
// Code generated by goderive DO NOT EDIT.

package mem

// deriveMem returns a memoized version of the input function.
func deriveMem(f func(version int, id int) (User, error)) func(version int, id int) (User, error) {
	type input struct {
		Param0 int
		Param1 int
	}
	type output struct {
		Res0 User
		Res1 error
	}
	m := make(map[input]output)
	return func(param0 int, param1 int) (User, error) {
		in := input{param0, param1}
		if o, ok := m[in]; ok {
			return o.Res0, o.Res1
		}
		res0, res1 := f(param0, param1)
		m[in] = output{res0, res1}
		return res0, res1
	}
}
```