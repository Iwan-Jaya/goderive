The deriveUnique function is useful for returning a list of unique items, when these items are not basic enough to be map keys.

Given the following input:

```go
package unique

type Visitor struct {
	UserName   *string
	RemoteAddr string
}

func uniqueVisitors(vs []*Visitor) int {
	return len(deriveUnique(vs))
}
```

goderive will generate the following code:

```go
// Code generated by goderive DO NOT EDIT.

package unique

func deriveUnique(list []*Visitor) []*Visitor {
	if len(list) == 0 {
		return nil
	}
	u := 1
	for i := 1; i < len(list); i++ {
		if !deriveContainsSliceOfPtrToVisitor(list[:u], list[i]) {
			if i != u {
				list[u] = list[i]
			}
			u++
		}
	}
	return list[:u]
}

func deriveContainsSliceOfPtrToVisitor(list []*Visitor, item *Visitor) bool {
	for _, v := range list {
		if deriveEqualPtrToVisitor(v, item) {
			return true
		}
	}
	return false
}

func deriveEqualPtrToVisitor(this, that *Visitor) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			((this.UserName == nil && that.UserName == nil) || (this.UserName != nil && that.UserName != nil && *(this.UserName) == *(that.UserName))) &&
			this.RemoteAddr == that.RemoteAddr
}
```